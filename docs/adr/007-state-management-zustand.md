# ADR-007: 状態管理ライブラリ: Zustand

## ステータス

Accepted

## コンテキスト

Anycast ではクライアントサイドの状態管理が必要である。

サーバー状態（API データ）は TanStack Query で管理しているが、以下のようなクライアント状態を管理する仕組みが必要:

- UI の状態（モーダルの開閉、サイドバーの状態など）
- 一時的なフォームの状態
- アプリケーション全体で共有する設定

## 決定

Zustand を採用する。

## 選択肢

### 選択肢 1: Zustand

- メリット
  - 軽量（約 1.2KB gzip）
  - ボイラープレートが少なく、学習コストが低い
  - React 19、Next.js App Router との相性が良い
  - DevTools 対応
  - TypeScript サポートが優秀
  - npm 週間ダウンロード数約 500 万で、広く使われている
- デメリット
  - グローバルストア形式のため、大規模になると管理が複雑になる可能性

### 選択肢 2: Jotai

- メリット
  - アトミックな状態管理で、細かい再レンダリング制御が得意
  - React の `useState` に近い API
  - TanStack Query との統合が可能
- デメリット
  - アトミック設計の理解が必要
  - Zustand より学習コストがやや高い

### 選択肢 3: Valtio

- メリット
  - プロキシベースで直感的な書き方が可能
  - ミュータブルなスタイルで記述できる
- デメリット
  - プロキシの挙動を理解する必要がある
  - Zustand や Jotai より採用事例が少ない

### 選択肢 4: React Context + useReducer

- メリット
  - 追加の依存関係なし
  - React の標準機能のみで実装可能
- デメリット
  - 大規模になると Context 地獄になりやすい
  - パフォーマンス最適化が手動で必要

## 理由

1. **シンプルさ**: 最小限の API で状態管理を実現でき、ボイラープレートが少ない
2. **軽量**: バンドルサイズへの影響が最小限
3. **実績**: 広く採用されており、ドキュメントやコミュニティが充実
4. **Next.js 対応**: App Router、Server Components との連携がスムーズ
5. **TanStack Query との棲み分け**: サーバー状態は TanStack Query、クライアント状態は Zustand と役割を明確に分離できる

## 結果

- `src/stores/` ディレクトリにストアを配置
- 機能ごとにストアを分割して管理
- DevTools を開発環境で有効化
